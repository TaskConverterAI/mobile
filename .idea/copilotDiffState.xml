<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FACTORY_ARCHITECTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FACTORY_ARCHITECTURE.md" />
              <option name="updatedContent" value="# Архитектура фабрики ViewModel в Kotlin Multiplatform&#10;&#10;## Проблема&#10;&#10;В Kotlin Multiplatform проекте нельзя использовать Android-специфичные классы (такие как `Application`, `APPLICATION_KEY`) в `commonMain` модуле.&#10;&#10;## Решение&#10;&#10;Мы используем **Dependency Injection** паттерн для создания `ViewModel` фабрик.&#10;&#10;### Структура&#10;&#10;1. **AuthViewModel** имеет companion object с методом `createFactory`:&#10;```kotlin&#10;companion object {&#10;    fun createFactory(authRepository: AuthRepository): ViewModelProvider.Factory = viewModelFactory {&#10;        initializer {&#10;            AuthViewModel(authRepository = authRepository)&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;2. **AuthViewModelFactory.kt** содержит вспомогательную функцию:&#10;```kotlin&#10;fun createAuthViewModelFactory(authRepository: AuthRepository): ViewModelProvider.Factory = &#10;    AuthViewModel.createFactory(authRepository)&#10;```&#10;&#10;3. **TaskConvertAIApp** принимает `AppContainer` как параметр:&#10;```kotlin&#10;@Composable&#10;fun TaskConvertAIApp(&#10;    appContainer: AppContainer,&#10;    viewModel: TaskConvertAIViewModel = viewModel(factory = TaskConvertAIViewModel.Factory),&#10;    navController: NavHostController = rememberNavController()&#10;)&#10;```&#10;&#10;4. При создании экранов используется:&#10;```kotlin&#10;RegistrationScreen(&#10;    authViewModel = viewModel(factory = createAuthViewModelFactory(appContainer.authRepository)),&#10;    // ...&#10;)&#10;```&#10;&#10;### Использование&#10;&#10;#### На Android стороне:&#10;&#10;В `MainActivity` (или где вызывается `TaskConvertAIApp`):&#10;&#10;```kotlin&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val application = application as TaskConvertAIApplication&#10;        &#10;        setContent {&#10;            TaskConvertAIAppTheme {&#10;                TaskConvertAIApp(&#10;                    appContainer = application.container&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;#### На iOS стороне:&#10;&#10;В iOS коде создается `AppContainer` и передается в Compose UI.&#10;&#10;## Преимущества&#10;&#10;1. ✅ **Кроссплатформенность**: Код в `commonMain` не зависит от платформо-специфичных классов&#10;2. ✅ **Тестируемость**: Легко инжектить mock-репозитории для тестов&#10;3. ✅ **Явные зависимости**: Видно, что нужно для создания ViewModel&#10;4. ✅ **Гибкость**: Можно легко изменить источник `AuthRepository`&#10;&#10;## Альтернативные подходы&#10;&#10;Если нужно полностью скрыть создание фабрики от вызывающего кода, можно использовать:&#10;- **Koin** - DI фреймворк для KMP&#10;- **Kodein** - еще один DI фреймворк&#10;- **expect/actual** паттерн для платформо-специфичного создания фабрик&#10;&#10;Но для простых случаев достаточно явной передачи зависимостей через параметры.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shared/src/androidMain/kotlin/com/example/taskconvertaiapp/shared/network/AuthApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shared/src/androidMain/kotlin/com/example/taskconvertaiapp/shared/network/AuthApiService.kt" />
              <option name="originalContent" value="package com.example.taskconvertaiapp.shared.network&#10;&#10;import com.example.taskconvertaiapp.shared.model.SignInUserRequest&#10;import com.example.taskconvertaiapp.shared.model.SignInUserResponse&#10;import com.example.taskconvertaiapp.shared.model.SignUpUserRequest&#10;import com.example.taskconvertaiapp.shared.model.SignUpUserResponse&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.POST&#10;&#10;interface AuthApiService {&#10;    @POST(&quot;auth/register&quot;)&#10;    suspend fun signUp(@Body user: SignUpUserRequest): Response&lt;SignUpUserResponse&gt;&#10;&#10;    @POST(&quot;auth/login&quot;)&#10;    suspend fun signIn(@Body user: SignInUserRequest): Response&lt;SignInUserResponse&gt;&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.taskconvertaiapp.shared.network&#10;&#10;import com.example.taskconvertaiapp.shared.model.SignInUserRequest&#10;import com.example.taskconvertaiapp.shared.model.SignInUserResponse&#10;import com.example.taskconvertaiapp.shared.model.SignUpUserRequest&#10;import com.example.taskconvertaiapp.shared.model.SignUpUserResponse&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.POST&#10;&#10;interface AuthApiService {&#10;    @POST(&quot;auth/register&quot;)&#10;    suspend fun signUp(@Body user: SignUpUserRequest): Response&lt;SignUpUserResponse&gt;&#10;&#10;    @POST(&quot;auth/login&quot;)&#10;    suspend fun signIn(@Body user: SignInUserRequest): Response&lt;SignInUserResponse&gt;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shared/src/androidMain/kotlin/com/example/taskconvertaiapp/shared/ui/screens/auth/AuthViewModelFactory.android.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shared/src/androidMain/kotlin/com/example/taskconvertaiapp/shared/ui/screens/auth/AuthViewModelFactory.android.kt" />
              <option name="updatedContent" value="package com.example.taskconvertaiapp.shared.ui.screens.auth&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import com.example.taskconvertaiapp.shared.data.DefaultAppContainer&#10;import com.example.taskconvertaiapp.shared.data.auth.AuthRepository&#10;&#10;// DataStore setup&#10;private const val AUTH_PREFERENCES = &quot;auth_preferences&quot;&#10;private val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(&#10;    name = AUTH_PREFERENCES&#10;)&#10;&#10;// Global application context holder&#10;private lateinit var applicationContext: Context&#10;&#10;// Initialize function to be called from Android Application class&#10;fun initializeAuthRepository(context: Context) {&#10;    applicationContext = context.applicationContext&#10;}&#10;&#10;// Actual implementation for Android&#10;actual fun provideAuthRepository(): AuthRepository {&#10;    val container = DefaultAppContainer(applicationContext.dataStore)&#10;    return container.authRepository&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shared/src/commonMain/kotlin/com/example/taskconvertaiapp/shared/ui/screens/auth/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shared/src/commonMain/kotlin/com/example/taskconvertaiapp/shared/ui/screens/auth/AuthViewModel.kt" />
              <option name="originalContent" value="package com.example.taskconvertaiapp.shared.ui.screens.auth&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.lifecycle.viewmodel.initializer&#10;import androidx.lifecycle.viewmodel.viewModelFactory&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;import com.example.taskconvertaiapp.shared.data.auth.AuthRepository&#10;&#10;data class SignUpUiState(&#10;    val username: String = &quot;&quot;,&#10;    val email: String = &quot;&quot;,&#10;    val password: String = &quot;&quot;,&#10;    val confirmPassword: String = &quot;&quot;,&#10;    val isUsernameCorrect: Boolean = true,&#10;    val isEmailCorrect: Boolean = true,&#10;    val isPasswordCorrect: Boolean = true,&#10;    val isConfirmPasswordCorrect: Boolean = true,&#10;    val usernameErrMsg: String = &quot;&quot;,&#10;    val emailErrMsg: String = &quot;&quot;,&#10;    val passwordErrMsg: String = &quot;&quot;,&#10;    val confirmPasswordErrMsg: String = &quot;&quot;,&#10;    val state: Int = 0&#10;)&#10;&#10;data class SignInUiState(&#10;    val username: String = &quot;&quot;,&#10;    val password: String = &quot;&quot;,&#10;    val state: Int = 0&#10;)&#10;&#10;class AuthViewModel(&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _signUpUiState = MutableStateFlow(SignUpUiState())&#10;    val signUpUiState: StateFlow&lt;SignUpUiState&gt; = _signUpUiState.asStateFlow()&#10;&#10;    private val _signInUiState = MutableStateFlow(SignInUiState())&#10;    val signInUiState: StateFlow&lt;SignInUiState&gt; = _signInUiState.asStateFlow()&#10;&#10;&#10;    fun checkLogin(login: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val isCorrectLength = login.length in 3..32&#10;&#10;        if (!isCorrectLength) {&#10;            errorMsg = &quot;Имя должно иметь длину 3 - 32 символа&quot;&#10;        }&#10;&#10;        val usernameRegex = Regex(&quot;^[a-zA-Z0-9]+$&quot;)&#10;        val isCorrectSymbols = usernameRegex.matches(login)&#10;&#10;        if (!isCorrectSymbols) {&#10;            errorMsg = &quot;Имя должно содержать только латинские буквы и цифры&quot;&#10;        }&#10;&#10;        val isCorrect = isCorrectSymbols &amp;&amp; isCorrectLength&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(username = login, isUsernameCorrect = isCorrect, usernameErrMsg = errorMsg)&#10;        }&#10;    }&#10;&#10;    fun checkEmail(email: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val emailRegex = Regex(&quot;^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\$&quot;)&#10;        val isCorrect = email.isNotEmpty() &amp;&amp; emailRegex.matches(email)&#10;&#10;        if (!isCorrect) {&#10;            errorMsg = &quot;Некорректный почтовый адрес&quot;&#10;        }&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(email = email, isEmailCorrect = isCorrect, emailErrMsg = errorMsg)&#10;        }&#10;    }&#10;&#10;    fun checkPassword(password: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val correctLength = password.length in 8..&lt;256&#10;&#10;        if (!correctLength) {&#10;            errorMsg = &quot;Пароль должен быть длиннее 7 символов&quot;&#10;        }&#10;&#10;        val hasUpperCase = password.any { it.isUpperCase() }&#10;&#10;        if (!hasUpperCase) {&#10;            errorMsg = &quot;Пароль должен содержать прописные буквы&quot;&#10;        }&#10;&#10;        val hasLowerCase = password.any { it.isLowerCase() }&#10;&#10;        if (!hasLowerCase) {&#10;            errorMsg = &quot;Пароль должен содержать строчные буквы&quot;&#10;        }&#10;&#10;        val hasDigit = password.any { it.isDigit() }&#10;&#10;        if (!hasDigit) {&#10;            errorMsg = &quot;Пароль должен содержать цифры&quot;&#10;        }&#10;&#10;        val hasSpecialChar = password.any { !it.isLetterOrDigit() }&#10;&#10;        if (!hasSpecialChar) {&#10;            errorMsg = &quot;Пароль должен содержать спецсимволы&quot;&#10;        }&#10;&#10;        val isCorrect = correctLength &amp;&amp; hasUpperCase &amp;&amp; hasLowerCase &amp;&amp; hasDigit &amp;&amp; hasSpecialChar&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(password = password, isPasswordCorrect = isCorrect, passwordErrMsg = errorMsg)&#10;        }&#10;&#10;        checkConfirmPassword(signUpUiState.value.confirmPassword)&#10;    }&#10;&#10;    fun checkConfirmPassword(confirmPassword: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val isCorrect = confirmPassword.equals(signUpUiState.value.password)&#10;&#10;        if (!isCorrect) {&#10;            errorMsg = &quot;Пароли не совпадают&quot;&#10;        }&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(&#10;                confirmPassword = confirmPassword,&#10;                isConfirmPasswordCorrect = isCorrect,&#10;                confirmPasswordErrMsg = errorMsg&#10;            )&#10;        }&#10;    }&#10;&#10;    fun updateLogin(login: String) {&#10;        _signInUiState.update { currentState -&gt;&#10;            currentState.copy(username = login)&#10;        }&#10;    }&#10;&#10;    fun updatePassword(password: String) {&#10;        _signInUiState.update { currentState -&gt;&#10;            currentState.copy(password = password)&#10;        }&#10;    }&#10;&#10;    fun validateSignUp() {&#10;        viewModelScope.launch {&#10;            val result = authRepository.signUp(&#10;                _signUpUiState.value.username,&#10;                _signUpUiState.value.email,&#10;                _signUpUiState.value.password&#10;            )&#10;&#10;            if (result) {&#10;                _signUpUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 1)&#10;                }&#10;            } else {&#10;                _signUpUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 0)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun validateSignIn() {&#10;        viewModelScope.launch {&#10;            val result = authRepository.signIn(&#10;                _signInUiState.value.username,&#10;                _signInUiState.value.password&#10;            )&#10;&#10;            if (result) {&#10;                _signInUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 1)&#10;&#10;                }&#10;            } else {&#10;                _signInUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 0)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signUp() {&#10;        if (!_signUpUiState.value.isUsernameCorrect ||&#10;            !_signUpUiState.value.isEmailCorrect ||&#10;            !_signUpUiState.value.isPasswordCorrect ||&#10;            !_signUpUiState.value.isConfirmPasswordCorrect&#10;        )&#10;            return&#10;        validateSignUp()&#10;    }&#10;&#10;    fun signIn() {&#10;        validateSignIn()&#10;    }&#10;&#10;    companion object {&#10;        val Factory: ViewModelProvider.Factory = viewModelFactory {&#10;            initializer {&#10;                val authRepository = com.example.taskconvertaiapp.shared.AppDependencies.container.authRepository&#10;                AuthViewModel(authRepository = authRepository)&#10;                val authRepository = com.example.taskconvertaiapp.shared.AppDependencies.container.authRepository&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.taskconvertaiapp.shared.ui.screens.auth&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.lifecycle.viewmodel.initializer&#10;import androidx.lifecycle.viewmodel.viewModelFactory&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;import com.example.taskconvertaiapp.shared.data.auth.AuthRepository&#10;&#10;data class SignUpUiState(&#10;    val username: String = &quot;&quot;,&#10;    val email: String = &quot;&quot;,&#10;    val password: String = &quot;&quot;,&#10;    val confirmPassword: String = &quot;&quot;,&#10;    val isUsernameCorrect: Boolean = true,&#10;    val isEmailCorrect: Boolean = true,&#10;    val isPasswordCorrect: Boolean = true,&#10;    val isConfirmPasswordCorrect: Boolean = true,&#10;    val usernameErrMsg: String = &quot;&quot;,&#10;    val emailErrMsg: String = &quot;&quot;,&#10;    val passwordErrMsg: String = &quot;&quot;,&#10;    val confirmPasswordErrMsg: String = &quot;&quot;,&#10;    val state: Int = 0&#10;)&#10;&#10;data class SignInUiState(&#10;    val username: String = &quot;&quot;,&#10;    val password: String = &quot;&quot;,&#10;    val state: Int = 0&#10;)&#10;&#10;class AuthViewModel(&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _signUpUiState = MutableStateFlow(SignUpUiState())&#10;    val signUpUiState: StateFlow&lt;SignUpUiState&gt; = _signUpUiState.asStateFlow()&#10;&#10;    private val _signInUiState = MutableStateFlow(SignInUiState())&#10;    val signInUiState: StateFlow&lt;SignInUiState&gt; = _signInUiState.asStateFlow()&#10;&#10;&#10;    fun checkLogin(login: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val isCorrectLength = login.length in 3..32&#10;&#10;        if (!isCorrectLength) {&#10;            errorMsg = &quot;Имя должно иметь длину 3 - 32 символа&quot;&#10;        }&#10;&#10;        val usernameRegex = Regex(&quot;^[a-zA-Z0-9]+$&quot;)&#10;        val isCorrectSymbols = usernameRegex.matches(login)&#10;&#10;        if (!isCorrectSymbols) {&#10;            errorMsg = &quot;Имя должно содержать только латинские буквы и цифры&quot;&#10;        }&#10;&#10;        val isCorrect = isCorrectSymbols &amp;&amp; isCorrectLength&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(username = login, isUsernameCorrect = isCorrect, usernameErrMsg = errorMsg)&#10;        }&#10;    }&#10;&#10;    fun checkEmail(email: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val emailRegex = Regex(&quot;^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\$&quot;)&#10;        val isCorrect = email.isNotEmpty() &amp;&amp; emailRegex.matches(email)&#10;&#10;        if (!isCorrect) {&#10;            errorMsg = &quot;Некорректный почтовый адрес&quot;&#10;        }&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(email = email, isEmailCorrect = isCorrect, emailErrMsg = errorMsg)&#10;        }&#10;    }&#10;&#10;    fun checkPassword(password: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val correctLength = password.length in 8..&lt;256&#10;&#10;        if (!correctLength) {&#10;            errorMsg = &quot;Пароль должен быть длиннее 7 символов&quot;&#10;        }&#10;&#10;        val hasUpperCase = password.any { it.isUpperCase() }&#10;&#10;        if (!hasUpperCase) {&#10;            errorMsg = &quot;Пароль должен содержать прописные буквы&quot;&#10;        }&#10;&#10;        val hasLowerCase = password.any { it.isLowerCase() }&#10;&#10;        if (!hasLowerCase) {&#10;            errorMsg = &quot;Пароль должен содержать строчные буквы&quot;&#10;        }&#10;&#10;        val hasDigit = password.any { it.isDigit() }&#10;&#10;        if (!hasDigit) {&#10;            errorMsg = &quot;Пароль должен содержать цифры&quot;&#10;        }&#10;&#10;        val hasSpecialChar = password.any { !it.isLetterOrDigit() }&#10;&#10;        if (!hasSpecialChar) {&#10;            errorMsg = &quot;Пароль должен содержать спецсимволы&quot;&#10;        }&#10;&#10;        val isCorrect = correctLength &amp;&amp; hasUpperCase &amp;&amp; hasLowerCase &amp;&amp; hasDigit &amp;&amp; hasSpecialChar&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(password = password, isPasswordCorrect = isCorrect, passwordErrMsg = errorMsg)&#10;        }&#10;&#10;        checkConfirmPassword(signUpUiState.value.confirmPassword)&#10;    }&#10;&#10;    fun checkConfirmPassword(confirmPassword: String) {&#10;        var errorMsg = &quot;&quot;&#10;        val isCorrect = confirmPassword.equals(signUpUiState.value.password)&#10;&#10;        if (!isCorrect) {&#10;            errorMsg = &quot;Пароли не совпадают&quot;&#10;        }&#10;&#10;        _signUpUiState.update { currentState -&gt;&#10;            currentState.copy(&#10;                confirmPassword = confirmPassword,&#10;                isConfirmPasswordCorrect = isCorrect,&#10;                confirmPasswordErrMsg = errorMsg&#10;            )&#10;        }&#10;    }&#10;&#10;    fun updateLogin(login: String) {&#10;        _signInUiState.update { currentState -&gt;&#10;            currentState.copy(username = login)&#10;        }&#10;    }&#10;&#10;    fun updatePassword(password: String) {&#10;        _signInUiState.update { currentState -&gt;&#10;            currentState.copy(password = password)&#10;        }&#10;    }&#10;&#10;    fun validateSignUp() {&#10;        viewModelScope.launch {&#10;            val result = authRepository.signUp(&#10;                _signUpUiState.value.username,&#10;                _signUpUiState.value.email,&#10;                _signUpUiState.value.password&#10;            )&#10;&#10;            if (result) {&#10;                _signUpUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 1)&#10;                }&#10;            } else {&#10;                _signUpUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 0)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun validateSignIn() {&#10;        viewModelScope.launch {&#10;            val result = authRepository.signIn(&#10;                _signInUiState.value.username,&#10;                _signInUiState.value.password&#10;            )&#10;&#10;            if (result) {&#10;                _signInUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 1)&#10;&#10;                }&#10;            } else {&#10;                _signInUiState.update { currentState -&gt;&#10;                    currentState.copy(state = 0)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signUp() {&#10;        if (!_signUpUiState.value.isUsernameCorrect ||&#10;            !_signUpUiState.value.isEmailCorrect ||&#10;            !_signUpUiState.value.isPasswordCorrect ||&#10;            !_signUpUiState.value.isConfirmPasswordCorrect&#10;        )&#10;            return&#10;        validateSignUp()&#10;    }&#10;&#10;    fun signIn() {&#10;        validateSignIn()&#10;    }&#10;&#10;    companion object {&#10;        val Factory: ViewModelProvider.Factory = viewModelFactory {&#10;            initializer {&#10;                val authRepository = com.example.taskconvertaiapp.shared.AppDependencies.container.authRepository&#10;                AuthViewModel(authRepository = authRepository)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shared/src/iosMain/kotlin/com/example/taskconvertaiapp/shared/ui/screens/auth/AuthViewModelFactory.ios.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shared/src/iosMain/kotlin/com/example/taskconvertaiapp/shared/ui/screens/auth/AuthViewModelFactory.ios.kt" />
              <option name="updatedContent" value="package com.example.taskconvertaiapp.shared.ui.screens.auth&#10;&#10;import com.example.taskconvertaiapp.shared.data.auth.AuthRepository&#10;import com.example.taskconvertaiapp.shared.data.auth.UserAuthPreferencesRepository&#10;import com.example.taskconvertaiapp.shared.data.createAuthRepository&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;&#10;// Platform-specific DataStore instance&#10;private lateinit var dataStoreInstance: DataStore&lt;Preferences&gt;&#10;&#10;// Initialize function to be called from iOS&#10;fun initializeAuthRepository(dataStore: DataStore&lt;Preferences&gt;) {&#10;    dataStoreInstance = dataStore&#10;}&#10;&#10;// Actual implementation for iOS&#10;actual fun provideAuthRepository(): AuthRepository {&#10;    val userAuthPreferencesRepository = UserAuthPreferencesRepository(dataStoreInstance)&#10;    return createAuthRepository(userAuthPreferencesRepository)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>